# 클린코드

<br>

> 컴퓨터가 아닌 사람이 읽고 이해하기 쉬운 코드

- 사람이 읽고 이해하기 쉽다.

- 명확한 한가지 역할을 하며, 이 역할을 의미있게 표현한다.

- 중복이 없다

- 테스트 케이스가 존재   
<br>

※ 나쁜코드: 대충 짰는데 돌아가는 코드
- 다른 개발자가 읽기 힘들다.

- 리팩토링이 힘들다.

- 의존성이 심하다.

- 생산성이 떨어진다.

- 재설계가 힘들다.

<br>
<br>

## 클린코드의 범위에 속하지 않는 것   

- 자료구조/알고리즘   

- SW의 성능 개선

- 신뢰성, 안정성을 위한 개발 기법

- SW 아키텍처 설계 기법

- 언어 별 Programming Best Practice

<br>
<br>

## 클린코드의 중요성

<br>

SW는 한번 신규 개발되면, 오랜 기간동안 유지보수 된다.      

기존 코드에 추가 작업하는 시간이 압도적으로 많다.   

대부분의 시간을 기존 코드를 읽고, 이해하는 데 사용된다.   

-  코드를 읽는 시간 : 코드를 짜는 시간 = 10 : 1   

Code의 품질이 낮아지면
- Code를 읽고 이해하는 데 더 많은 시간이 걸린다.   

- 복잡도가 상승하여 코드를 수정하는 데 더 많은 시간이 걸린다.
- 테스트 코드가 없어서, 하나를 수정하면 여러 곳에서 Side-effect가 발생한다.

<br>

![img](https://raw.githubusercontent.com/Songwonseok/CS-Study/main/CommonSense/images/cleancode-refactoring-1.JPG)   
변경 비용과 대응속도에 대한 이상치와 실제 프로젝트에서 발생하는 수치   

![img](https://blog.kakaocdn.net/dn/umdrS/btruryhgNMo/BuFRKFnumoDpP0DjL6hKV0/img.png)   
Technical Debt: 실제 변경 비용과 이상적인 변경 비용과의 차이   
<br>
<br>

## Clean Code의 주요원칙   

### 1. General
- Follow Standard Conventions   
Coding 표준, 아키텍처 표준 및 설계 가이드를 준수하라.

- Keep It Simple, Stupid (KISS)   
단순한 것이 효율적이며, 복잡함을 최소화하라.

- Boy Scout Rule   
캠핑장을 떠나기 전에 원래보다 깨끗하게 해야 한다. (참조되거나 수정되는 코드는 원래보다 clean하게 해야 함)   

- Root Cause Analysis  
항상 근본적인 원인을 찾아라. 그렇지 않으면 반복될 것이다.

- Do Not Multiple Languages in One Source File   
하나의 언어는 하나의 파일로 작성해야 한다.

### 2. Class Design (SOLID)
- S 단일 책임 원칙 (Single Responsibility Principle)
한 클래스는 하나의 책임만 가져야 한다.

- O 개방-폐쇄 원칙 (Open/Closed Principle)
클래스는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

- L 리스코프 치환 원칙 (Liskov Substitution Principle)
파생 클래스의 메소드는 기반 클래스의 메소드를 대체하여 사용될 수 있어야 한다.

- I 인터페이스 분리 원칙 (Interface Segregation Principle)
클라이언트가 사용 하지 않는 메소드에 의존하지 않아야 한다.

- D 의존관계 역전 원칙 (Dependency Inversion Principle)
추상화된 것은 구체적인 것에 의존하면 안된다. (자주 변경되는 구체적인 것에 의존하지 말고 추상화된 것을 참조)

<br>
<br>

## 그 밖의 클린코드 특징

### 1. Naming
- 의미 있는 이름을 사용하자.
  ```
  //before
  string id; //사용자 계정
  string pwd;//비밀번호
  string rm; //학번
  string em; //이메일

  //after
  string studentId;
  string studentPassword;
  string studentSequenceNumber;
  string studentname;
  string studentEmailAddress; 
  ```
- do( ), process( )와 같이 너무 일반적인 이름보다는 이름만으로도 언제 이 메서드를 호출해야 하는지 의미를 파악할 수 있도록 구체적으로 작성하자. 

### 2. Style
- 적절한 행 길이와 들여 쓰기를 유지하고, 개념은 빈행으로 분리하라.

- 변수는 사용하는 위치에 최대한 가까이 선언해라.   

- if/else 조건문에서 인수의 순서는 긍정적이고, 간단한 표현이 앞쪽에 위치하도록 하는 것이다.

- 삼항연산자(? :)나 do/while 구문은 코드의 가독성을 떨어뜨리기 때문에 되도록 사용하지 않는 것이 바람직하다.

  - 삼항연산자보다 if 문으로 작성하는 편이 자연스럽다.

### 3. Coment
- 주석으로 나쁜 코드를 보완하지 말고, 코드의 의도를 표현하라.

- 주석도 최대한 정성스럽게 작성해야 한다.

- 나중에 다시 사용하거나 임시로 저장한 코드에 주석처리 하는 경우도 있는데, 이는 보는 사람에게 혼란을 준다. 과감하게 삭제시키자.

- (이 코드가 다른 코드에 어떤 영향을 줄 수 있는지 알려주는 주석은 좋은 주석)

### 4. Dead Code
- 사용하지 않는 코드는 과감히 지워라(주석처리하지 않는다).

### 5. Method
- 함수에서 인수의 개수는 적을수록 좋다.

- 함수의 크기는 20줄 이내, 한라인당 150문자를 넘지 않도록 한다.  

- 최대한 단순하게 처리하자.

- 단일 역할을 수행하도록 한다. 의도하지 않은 결과를 초래하지 않도록 하자. 

<br>
<br>

## 클린코드는 좋은 코드가 맞을까?

### 클린코드에 대한 비판

코드는 여러가지 이유로 훌륭할 수 있음   
-  읽기 쉬운, 이해하기 쉬운, 간단한, 성능 좋은, 안전한, 우아한, 테스트 가능한, 캡슐화된, 확장가능한, 유지보수 가능한, 재사용 가능한..

그러나 이러한 특성들은 어떤 면에서는 서로 상충됨   
-  가장 단순한 코드는 아마도 가장 테스트하기 쉽지는 않을 것   
- 인터페이스와 주입된 종속성은 테스트를 편리하게 하지만, 단순성과는 거리가 있음   
- 싱글톤을 많이 쓰면 이해하기는 쉽지만, 유지보수 가능한 어플리케이션은 아닐 수 있음   

이런것 중 일부는 근본적으로 반대되는 것들이라 동시에 모두 충족하기는 어려울수 도 있음   
- 모두가 동의할 수 있는 확실한 용어를 사용하기   
ㅤex:  캡슐화(encapsulated), 테스트 용의성(testable), 목 생성 용의성(mockable), 재사용성(reusable)   
ㅤ→ 코드가 왜 클린한 지 설명할 수 있어야 함
```ㅤ
나는 솔루션 X를 좋아한다. 솔루션 X가 더 클린해 보이기 때문이다.
```
or
```
나는 솔루션 X를 좋아한다. 솔루션 X는 코어로직과 에러 메시지를 디커플링 시키며, 두 로직을 같이 생각하지 않아도 되기 때문에 이해하기 더 쉽다. 또한 어떤 면에서는 목을 사용할 수 있기 때문에 테스트 하기 쉽다. 부모 객체에 의존성을 주입해야 되는 비용이 발생하지만 테스트의 용의성을 위해서 감수할만한 트레이드 오프이다.
```
- 엔지니어링은 Trade-off(절충) 이므로, 여기서 얘기하는 절충안을 가지고 팀에서 논의 해보는 것도 가능할 것